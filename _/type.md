The classes symbolize a logical categorization of technological components based on their primary function and phase in an operational cycle. This spectrum stretches from conceptualization and planning (Design) through actualizing and implementing (Development), to delivering and utilizing (Execution). While originally rooted in the software realm, this classification can be aptly applied across various domains, elucidating the primary function of technological components in diverse operational contexts.

## Operational Phases

### Design

- **[[Languages]]**: Representations or syntaxes that help structure, model, or dictate processes.
- **[[Principles]]**: Foundational theories, guidelines, or doctrines directing the design or planning of solutions.
- **[[Architectures]]**: Structural outlines or blueprints defining components' composition and interaction, whether technological or procedural.
- **[[Frameworks]]**: Structured guidelines or sets of rules that help streamline the creation or formulation of solutions.
### Development

- **[[Compilers]]**: Systems or tools that transform or interpret designs into actionable outputs.
- **[[Libraries]]**: Collections of resources, be they code or other assets, meant to enhance functionality or efficiency.

### Execution

- **[[Platforms]]**: Environments or systems that host, facilitate, or support the operationalization of solutions.
- **[[Tools]]**: Instruments or utilities that assist by automating or streamlining specific tasks or operations, from software applications to physical devices.
- **[[Services]]**: Autonomous or semi-autonomous entities that deliver specific functionalities or services, often without needing deep interaction or understanding of their internals.
- **[[Stores]]**: Repositories or systems that manage and retrieve resources or data.
- **[[Plugins]]**: Add-ons or extensions that enhance or modify the capabilities of an existing system, tool, service, or store.
