---
title: Type
---
The technology type helps us distinguish and position various technologies, allowing us to make more informed decisions about their adoption and relevance within our ecosystem.

Our operational lifecycle is broadly segmented into Design, Interaction, Development, and Operation. While the type originated in the software domain, its versatility provides clarity across various technological contexts.

## Design

In the design phase, the focus is on conceptualizing and planning a solution. Here, the foundation is laid for what will eventually become tangible software or technology.

- [[language|Languages]]. These define the syntax and structure, shaping the logic of the source code.
- [[architecture|Architectures]]. These theories and guidelines determine how a software component should interact with other components.
- [[blueprint|Blueprints]]. The definition of a software component that .
- [[pattern|Patterns]]. Fundamental theories, guidelines, or doctrines that steer the design of a software component.
- [[convention|Conventions]]. Non-functional rules and standards that guide but do not alter the logic of the source code.

## Interaction

- [[stories|Stories]]. Concise narratives that outline user experiences and interactions with software, focusing on achieving specific user outcomes.
- [[process|Processes]]. Structured sequences of actions facilitate stakeholders' creation, deployment, and use of software.
- [[soft-skills|Soft Skills]]. Essential interpersonal abilities that enhance communication, collaboration, and problem-solving in technology environments.

## Development

Once the foundation is set, the development phase begins. The concepts transition from theory to practice, transforming ideas into functional software or tech components.

- [[framework|Frameworks]]. These are structured guidelines, or rule sets that aid in efficiently creating solutions.
- [[library|Libraries]]. Collections of resources, such as code or assets, are designed to augment the source code.
- [[compiler|Compilers]]. Systems or tools that convert source code into a functional software component.
- [[interpreter|Interpreters]]. Tools or systems that interpret source or byte code, bringing a software component to life.

## Operation

In the execution phase, software components are deployed and utilized. This is where they interact, function, and provide their intended value within a more extensive system or as standalone entities.

- [[platform|Platforms]]. Environments or systems in which software components are hosted and run. They provide the necessary infrastructure for the components to operate seamlessly.
- [[tool|Tools]]. Standalone utility software components designed for specific tasks. Once executed, they complete their designated function and deliver the intended outcome, streamlining or automating particular processes within the larger system.
- [[service|Services]]. Software entities that deliver predefined functionalities. They operate autonomously, offering services without requiring deep interaction or understanding of their underlying mechanisms.
- [[store|Stores]]. Software repositories or systems that manage and retrieve data or other software resources.
- [[plugin|Plug-ins]]. Software add-ons or modifications that amplify or modify the capabilities of an existing component, be it a platform, tool, service, or store.